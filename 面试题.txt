一、python3和python2有什么区别？
python2中print是一个语句，不论想输出什么，直接放到print关键字后面即可。
python3里，print()是一个函数，像其他函数一样，print()需要你将要输出的东西作为参数传给它。

range 和 xrange区别
range
    python2 返回队列。
    python3 返回生成器。一边循环一边调用，每次只返回一个值。减少内存使用量。
xrange
    python2 返回生成器。
    python3 废弃。

python２有两个全局函数可以把对象强制转换成字符串:unicode()把对象转换成unicode字符串，还有str()把对象转换为非Unicode字符串。
Python3只有一种字符串类型，unicode字符串，所以str()函数即可完成所有的功能。

Python2支持<>作为!=的同义词，　python3只支持!=, 不再支持<>

通过input()解析用户的输入：
python3中input得到的为str；
Python2的input的到的为int型，Python2的raw_input得到的为str类型）
统一一下：Python3中用input，Python2中用row_input，都输入为str

在python2里，许多字典类方法的返回值是列表。最常用方法有keys, items和values。
python3，所有以上方法的返回值改为动态视图。
在一些上下文环境里，这种改变不会产生影响。如果这些方法的返回值被立即传递给另外一个函数，而且那个函数会遍历整个序列，
那么以上方法的返回值是列表或视图并不会产生什么不同。
如果你期望获得一个被独立寻址元素的列表，那么python3的这些改变将会使你的代码卡住，因为视图不支持索引。



二、什么是GIL
它是在实现Python解析器(CPython)时所引入的一个概念，GIL并不是Python的特性，Python完全可以不依赖于GIL。
利用多核，Python开始支持多线程。而解决多线程之间数据完整性和状态同步的最简单方法自然就是加锁
为了让各个线程能够平均利用CPU时间，python会计算当前已执行的微代码数量，达到一定阈值后就强制释放GIL。而这时也会触发一次操作系统的线程调度
任何一个线程被唤起时都能成功获得到GIL（因为只有释放了GIL才会引发线程调度）
GIL的存在导致多线程无法很好的立即多核CPU的并发处理能力。
用multiprocess替代Thread

multiprocess库的出现很大程度上是为了弥补thread库因为GIL而低效的缺陷。它完整的复制了一套thread所提供的接口方便迁移。
唯一的不同就是它使用了多进程而不是多线程。每个进程有自己的独立的GIL，因此也不会出现进程之间的GIL争抢。


三、进程之间是怎么进行通信的？
1.Queue使用方法：
Queue.qsize()：返回当前队列包含的消息数量；
Queue.empty()：如果队列为空，返回True，反之False ；
Queue.full()：如果队列满了，返回True,反之False；
Queue.get():获取队列中的一条消息，然后将其从列队中移除，可传参超时时长。
Queue.get_nowait()：相当Queue.get(False),取不到值时触发异常：Empty；
Queue.put():将一个值添加进数列，可传参超时时长。
Queue.put_nowait():相当于Queue.get(False),当队列满了时报错：Full。

#!/usr/bin/env python3

import time
from multiprocessing import Process,Queue

q = Queue()  #创建列队，不传数字表示列队不限数量
for i in range(11):
    q.put(i)

def A():
    while 1:
        try:
            num = q.get_nowait()
            print('我是进程A,取出数字:%d'%num)
            time.sleep(1)
        except :
            break

def B():
    while 1:
        try:
            num = q.get_nowait()
            print('我是进程B,取出数字:%d'%num)
            time.sleep(1)
        except :
            break

p1 = Process(target = A)
p2 = Process(target = B)
p1.start()
p2.start()

我是进程A,取出数字:0
我是进程B,取出数字:1
我是进程A,取出数字:2
我是进程B,取出数字:3
我是进程A,取出数字:4
我是进程B,取出数字:5
我是进程B,取出数字:6
我是进程A,取出数字:7
我是进程B,取出数字:8
我是进程A,取出数字:9
我是进程B,取出数字:10


使用进程池Pool时，Queue会出错，需要使用Manager.Queue：
#!/usr/bin/env python3

import time
from multiprocessing import Pool,Manager,Queue

q = Manager().Queue()
for i in range(11):
    q.put(i)

def A(i):
    num = q.get_nowait()
    print('我是进程%d,取出数字:%d'%(i,num))
    time.sleep(1)
            

pool = Pool(3)

for i in range(10):
    pool.apply_async(A,(i,))

pool.close()
pool.join()
我是进程1,取出数字:0
我是进程0,取出数字:1
我是进程2,取出数字:2
我是进程4,取出数字:3
我是进程3,取出数字:4
我是进程5,取出数字:5
我是进程6,取出数字:6
我是进程7,取出数字:7
我是进程8,取出数字:8
我是进程9,取出数字:9

四、@staticmethod（静态方法）和@classmethod（类方法）的区别？
一般来说，要使用某个类的方法，需要先实例化一个对象再调用方法。

而使用@staticmethod或@classmethod，就可以不需要实例化，直接类名.方法名()来调用。

这有利于组织代码，把某些应该属于某个类的函数给放到那个类里去，同时有利于命名空间的整洁
@staticmethod不需要表示自身对象的self和自身类的cls参数，就跟使用函数一样。
@classmethod也不需要self参数，但第一个参数需要是表示自身类的cls参数。
如果在@staticmethod中要调用到这个类的一些属性方法，只能直接类名.属性名或类名.方法名。
而@classmethod因为持有cls参数，可以来调用类的属性，类的方法，实例化对象等
class A(object):  
    bar = 1  
    def foo(self):  
        print 'foo'  
 
    @staticmethod  
    def static_foo():  
        print 'static_foo'  
        print A.bar  
 
    @classmethod  
    def class_foo(cls):  
        print 'class_foo'  
        print cls.bar  
        cls().foo()  
  
A.static_foo()  
A.class_foo()  
输出
static_foo
1
class_foo
1
foo

五、python里面如何拷贝一个对象，并解释深浅拷贝？
a = [1, 2, 3, 4, ['a', 'b']] 
b = a 
c = copy.copy(a) 
d = copy.deepcopy(a) 
 
a.append(5) 
a[4].append('c') 
 
print 'a = ', a
print 'b = ', b
print 'c = ', c
print 'd = ', d

    a =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
    b =  [1, 2, 3, 4, ['a', 'b', 'c'], 5]
    c =  [1, 2, 3, 4, ['a', 'b', 'c']]        ！！！
    d =  [1, 2, 3, 4, ['a', 'b']]

所以说copy会对原对象拷贝，但不会递归深拷贝，而deepcopy是递归深拷贝的，这么一来copy是介于=和deepcopy的，用的肯定不多。

1. copy.copy 浅拷贝 只拷贝父对象，不会拷贝对象的内部的子对象。 
2. copy.deepcopy 深拷贝 拷贝对象及其子对象 


六、python中search()和match()的区别？
match
只有在0位置匹配成功的话才有返回，如果不是开始位置匹配成功的话，match()就返回none
search
搜索整个字符串


七、迭代器和生成器的区别？
迭代器的实质是实现了next()方法的对象，常用的元组、列表、字典都是迭代器
迭代器中重点关注两个方法：
__iter__方法：返回迭代器自身。可以通过python内建函数iter()调用
__next__方法：当next方法被调用的时候，迭代器会返回它的下一个值，如果next方法被调用，但迭代器没有值可以返回，就会引发一个StopIteration异常。该方法可以通过python内建函数next()调用


生成器：
简单来说，生成器是包含yield关键词的函数。本质上来说，关键字yield是一个语法糖，内部实现支持了迭代器协议
生成器最重要的功能，我们可以通过send()方法，向生成器内部传递参数。
a. 当生成器被调用的时候，函数体的代码不会被执行，而是会返回一个迭代器
“生成器的迭代器”这个术语通常被称作”生成器”。生成器就是一类特殊的迭代器。
作为一个迭代器，生成器必须要定义一些方法，其中一个就是next()如同迭代器一样，我们可以使用next()函数来获取下一个值，这一切都是在yield内部实现的。

b. 当next()方法第一次被调用的时候，生成器函数才开始执行，执行到yield语句处停止,next()方法的返回值就是yield语句处的参数（yielded value）
当继续调用next()方法的时候，函数将接着上一次停止的yield语句处继续执行，并到下一个yield处停止；如果后面没有yield就抛出StopIteration异常。


d. 生成器的编写方法和函数定义类似，只是在return的地方改为yield。生成器中可以有多个yield。当生成器遇到一个yield时，会暂停运行生成器，返回yield后面的值。
当再次调用生成器的时候，会从刚才暂停的地方继续运行，直到下一个yield。生成器自身又构成一个循环器，每次循环使用一个yield返回的值

八、什么是协程，python协程是怎么实现的？
   协程就是在一个线程执行过程中可以在一个子程序的预定或者随机位置中断，然后转而执行别的子程序，在适当的时候再返回来接着执行。它本身就是一种特殊的子程序或者成为函数
  协程基于generator，python3中内置了异步I/O。
  Python里面一般用gevent实现协程， 而协程就是在等待的时候切换去做别的操作，相当于将一个线程分块，充分利用资源

九、什么是装饰器？
 装饰器本质上是一个python函数，它可以让其它函数在不需要做任何代码变动的前提下增加额外的功能，装饰器的返回值也是一个函数对象
 有了装饰器我们就可以抽离大量与函数功能本身无关的雷同代码并继续重用


十、简述一下select和epoll的原理和区别？
 select,poll,epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是 读就绪或写就绪），能够通知程序进行相应的读写操作。但select,poll,epoll本质上都是同步I/O，因为他们都是需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的，而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间内核中的select实现中,它是采用轮询来处理的,轮询的fd数据数据越多,自然耗时就越多.,epoll最大的好处在于它不会随着监听fd数目的增长而降低效率
在select中采用轮询处理，其中的数据结构类似一个数组的数据结构，而epoll
是维护一个队列，直接看队列是不是空就可以了。epoll只会对"活跃"的socket进行操作---这是因为在内核实现中epoll是根据每个fd上面的callback函数实现的。那么，只有"活跃"的socket才会主动的去调用 callback函数（把这个句柄加入队列），其他idle状态句柄则不会，在这点上，epoll实现了一个"伪"AIO。但是如果绝大部分的I/O都是“活跃的”，每个I/O端口使用率很高的话，epoll效率不一定比select高（可能是要维护队列复杂）。

十一、python的垃圾回收机制？
Python的GC模块主要运用了“引用计数”（reference counting）来跟踪和回收垃圾。在引用计数的基础上，还可以通过“标记-清除”（mark and sweep）解决容器对象可能产生的循环引用的问题。
通过“分代回收”（generation collection）以空间换取时间来进一步提高垃圾回收的效率。

原理：将系统中的所有内存块根据其存活时间划分为不同的集合，每一个集合就成为一个“代”，垃圾收集的频率随着“代”的存活时间的增大而减小。也就是说，
活得越长的对象，就越不可能是垃圾，就应该减少对它的垃圾收集频率。那么如何来衡量这个存活时间：通常是利用几次垃圾收集动作来衡量，如果一个对象经过的垃圾收集次数越多，可以得出：该对象存活时间就越长。

十二、python socket编程？
两个程序通过“网络”交互数据就使用socket，它只负责两件事：建立连接，传递数据
socket通常也称为作“套接字”，用于描述IP地址和端口，是一个通信链的句柄，应用程序通常通过“套接字”向网络发出请求或者应答网络请求
socket和file的区别：
file模块是针对某个指定文件进行打开、读写、关闭
socket模块是针对服务器端和客户端socket进行打开、读写、关闭
SocketTCP服务器编程步骤：1、打开socket，2、绑定到一个地址和端口，3、侦听进来的连接，4、接受连接，5、读写数据，6、关闭socket。      
SocketTCP客户端编程步骤：1、打开socket，2、连接到服务器，3、读写数据，4、关闭socket。

十三、TCP和HTTP的区别？
Http是无状态的短连接，而TCP是有状态的长连接
TCP协议对应于传输层，而HTTP协议对应于应用层
从本质上来说，二者没有 可比性。Http协议是建立在TCP协议基础之上的，
当浏览器需要从服务器获取网页数据的时候，会发出一次Http请求。Http会通过TCP建立起一个 到服务器的连接通道，
当本次请求需要的数据完毕后，Http会立即将TCP连接断开，这个过程是很短的。所以Http连接是一种短连接，是一种无状态的连接。
所谓的无状态，是指浏览器每次向服务器发起请求的时候，不是通过一个连接，而是每次都建立 一个新的连接。如果是一个连接的话，
服务器进程中就能保持住这个连接并且在内存中记住一些信息状态。而每次请求结束后，连接就关闭，相关的内容就释放了，所以记不住任何状态，成为无状态连接。


十四、MylSAM和InnoDB的特点？
是mysql的两个引擎
myisam支持全文检索(fulltext),相对简单所以在效率上要优于InnoDB.如果系统读多，写少。且MyISAM恢复速度快。可直接用备份覆盖恢复
InnoDB不支持全文检索，如果系统读少，写多的时候，尤其是并发写入高的时候。InnoDB就是首选了



Cookie与Session的区别
cookie数据存放在客户的浏览器上，session数据放在服务器上；
cookie不是很安全，别人可以分析存放在本地的COOKIE并进行COOKIE欺骗，考虑到安全应当使用session；
session会在一定时间内保存在服务器上。当访问增多，会比较占用你服务器的性能。考虑到减轻服务器性能方面，应当使用COOKIE；
单个cookie在客户端的限制是3K，就是说一个站点在客户端存放的COOKIE不能超过3K；
Cookie和Session的方案虽然分别属于客户端和服务端，但是服务端的session的实现对客户端的cookie有依赖关系的，
上面我讲到服务端执行session机制时候会生成session的id值，这个id值会发送给客户端，客户端每次请求都会把这个id值放到http请求的头部发送给服务端，
而这个id值在客户端会保存下来，保存的容器就是cookie，因此当我们完全禁掉浏览器的cookie的时候，服务端的session也会不能正常使用


uWSGI是一个Web服务器，它实现了WSGI协议、uwsgi、http等协议。Nginx中HttpUwsgiModule的作用是与uWSGI服务器进行交换。
要注意 WSGI / uwsgi / uWSGI 这三个概念的区分。
WSGI是一种通信协议。
uwsgi是一种线路协议而不是通信协议，常用于在uWSGI服务器与其他网络服务器的数据通信。
而uWSGI是实现了uwsgi和WSGI两种协议的Web服务器。
uwsgi协议是一个uWSGI服务器自有的协议，它用于定义传输信息的类型（type of information），每一个uwsgi packet前4byte为传输信息类型描述，它与WSGI相比是两样东西。


Nginx是一款轻量级的Web 服务器/反向代理服务器及电子邮件（IMAP/POP3）代理服务器，并在一个BSD-like 协议下发行。其特点是占有内存少，并发能力强，
事实上nginx的并发能力确实在同类型的网页服务器中表现较好，中国大陆使用nginx网站用户有：百度、京东、新浪、网易、腾讯、淘宝等。
Nginx作为负载均衡服务器：Nginx 既可以在内部直接支持 Rails 和 PHP 程序对外进行服务，也可以支持作为 HTTP代理服务器对外进行服务。Nginx采用C进行编写，
不论是系统资源开销还是CPU使用效率都比 Perlbal 要好很多。处理静态文件，索引文件以及自动索引;打开文件描述符缓冲。无缓存的反向代理加速，简单的负载均衡和容错


 psutil是一个跨平台库（http://code.google.com/p/psutil/），能够轻松实现获取系统运行的进程和系统利用率（包括CPU、内存、磁盘、网络等）信息。它主要应用于系统监控，分析和限制系统资源及进程的管理


1、Ajax是异步的JavaScript和xml,优点是在不重新加载整个页面的情况下，对网页的某部分进行更新，可以与服务器交换数据并更新部分网页内容，它不需要任何浏览插件，但需要用户允许JavaScript在浏览器上执行，ajax可以使网页实现异步更新。




question：mysql、redis、mogodb数据库的区别和原理

4、MongoDB 是一个基于分布式文件存储的数据库。由 C++ 语言编写
MongoDB 是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的

5、Redis 是完全开源免费的，遵守BSD协议，是一个高性能的key-value数据库。
如果简单地比较Redis与Memcached的区别，大多数都会得到以下观点：
Redis 与其他 key - value 缓存产品有以下三个特点：
Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用。
Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。

6、MySQL是Web世界中使用最广泛的数据库服务器。SQLite的特点是轻量级、可嵌入，但不能承受高并发访问，适合桌面和移动应用。
而MySQL是为服务器端设计的数据库，能承受高并发访问，同时占用的内存也远远大于SQLite。此外，MySQL内部有多种数据库引擎，最常用的引擎是支持数据库事务的InnoDB。

0、进程、线程、协程
    未解答


7.总结 Django 和 Flask 的特点：
    （1）Flask
    Flask自由、灵活，可扩展性强，第三方库的选择面广，开发时可以结合自己最喜欢用的轮子，也能结合Python库
    非常适用于开发web服务的API
    开发大型网站无压力，但代码架构需要自己设计，开发成本取决于开发者的能力和经验
    Django自带的或第三方的好评如潮的功能，Flask上总会找到与之类似第三方库
    Flask与关系型数据库的配合使用不弱于Django，而其与NoSQL数据库的配合远远优于Django
   （2）Django
    Django太重了，除了web框架，自带ORM和模板引擎，灵活和自由度不够高
    Django的自带ORM非常优秀，综合评价略高于SQLAlchemy
    Django自带ORM也使Django与关系型数据库耦合度过高
    Django自带的数据库管理app
    Django非常适合企业级网站的开发：快速、靠谱、稳定
    Django是Python web框架的先驱，用户多，第三方库最丰富，最好的Python库


## AOP（面向切面编程），可以理解为Django中的中间件

主要功能
    日志记录，性能统计，安全控制，事务处理，异常处理等等。
主要意图
    将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，改变这些行为的时候不影响业务逻辑的代码。


11.什么是ORM？ORM的作用？
对象关系映射（Object Relational Mapping，简称ORM）模式是一种为了解决面向对象与关系数据库存在的互不匹配的现象的技术。
简单的说，ORM是通过使用描述对象和数据库之间映射的元数据，将程序中的对象自动持久化到关系数据库中。


常用的linux命令：
ls --help
man ls查看使用手册

ls -a 看隐藏的文件 ls -l以列表的方式显示文件的详细信息 ls -h配合-l一人性化的方式显示文件大小

pwd 显示当前的工作目录

cd .切换到当前目录 cd ..切换到上级目录 cd ~切换到当前的用户的主目录 
cd -可进入上次所在的目录

ls > test.txt输出重定向，linux允许将命令执行结果重定向到一个文件。本应显示在终端上的内容保存到指定文件中，如果文件不存在，则创建，（存在则覆盖其内容）

ls>>text.txt输出重定向，linux允许将命令执行结果重定向到一个文件。本应显示在终端上的内容保存到指定文件中，如果文件不存在，则创建，（存在则追加到文件指定文件中）

cat test1.txt test2.txt > test.txt查看或者合并文件的内容

head test.txt默认显示前10行

head -n test.txt显示前n行

tail test.txt 默认显示后10行 tail -n test.txt显示后10行

less text.txt 查看文件

clear 清空

mkdir -p a/b/c/d 那个-p如果不写的话就不能一直递归创建目录

touch创建一个新的普通文件 vim也会创建文件 cat >> 也可以 有追加没有创建

rm -r 删除命令

cp -a a目录名 b复制到的目录名

cp -f a已经存在的文件名 b复制到的目录名

cp -r a目录文件 b复制到的目录名（递归复制a该目录下的所有的子目录和文件，目录文件必须为一个目录名）

mv 文件 目标目录 移动文件或目录

mv 文件名 文件名 重命名

创建 软连接  ln -s 源文件 链接文件

如果软连接文件和源文件不在同一个目录，源文件要使用绝对路径，不能使用相对路径

创建 硬链接  ln 源文件 链接文件

两个文件占用相对大小的硬盘空间，即使删除了源文件，链接文件还是存在，所以-s选项是
更常见的形式

查看进程 ps -aux | grep 
ps -A 显示所有进程
ps -f 显示程序间的关系
netstat anput | grep        查看端口号
lsof -i:port                查看端口的PID
ps -ef                      查看所有级命令行，也查看端口的PID
kill -9 PID                 杀死进程

查看的进程的名字,其中|是通道，是把上个参数的输出当作下个参数的输入

find ./ -文件名 test.sh 查看当前下所有名为test.sh的文件

find ./ -文件名 '*.sh' 查看当前目录下所有后缀为.sh的文件

find ./ -文件名 "[A-Z]*" 查看当前目录下所有以大写字母开头的文件

find ./tmp -size 2M 查看在/tem目录下等于2M的文件

find ./tmp -size +2M 查看在/tem目录下大于2M的文件

find ./tmp -size -2M 查看在/tem目录下小于2M的文件

find ./ -size +2K -size -5M 查看在当前目录下大于2K，小于5M的文件

find ./ -perm 0777 查看当前目录下权限为777的文件或目录

tar -cvzf 打包文件名 文件 压缩 tar -cvzf all.tar *.jpg 将所有的.jpg文件打成一个名为all.tar包

tar -xvzf 打包文件名 解压缩
tar -xzvf file.tar.gz 解压tar.gz
tar -xzvf 1.tar.gz -C /temp解压到指定目录

unzip file.zip 解压zip
gzip -r 1.tar 1.tar.gz 压缩所有的子目录  gzip [参数] 被压缩文件 压缩后文件名
gzip -d 1.tar.gz 解压 gzip [参数] 待解压文件

vim 待打开的文件名 如果不存在则先打开，当关闭保存时会自动创建该文件

vim ~/.vimrc打开配置文件

whoami查看当前系统当前账号的用户名

exit 退出

useradd [参数] 新建用户账号
passwd 超级用户可以使用passwd命令为普通用户设置或修改用户口令
userdel 删除用户
userdel kaige 删除kaige用户，但不会自动删除用户的主目录
userdel -r kaige 删除用户，同时删除用户的主目录

su 切换用户
su - 切换到对应的用户时会将当前的工作目录自动转换到切换后的用户主目录

groupadd 新建组账号
groupdel 删除组账号
usermod 修改用户的所在组 usermod -g 用户组 用户名
groups sunck 查看用户在哪些组
sudo usermod -a -G adm 用户名
sudo usermod -a -G sudo 用户名 为创建的普通用户添加sudo权限


连接MYSQL：mysql -h 主机地址 -u 用户名 -p 用户密码 mysql -u root -p 

格式：mysqladmin -u用户名 -p旧密码 password 新密码

1、例1：给root加个密码ab12。首先在DOS下进入目录mysqlbin，然后键入以下命令：
mysqladmin -uroot -password ab12
注：因为开始时root没有密码，所以-p旧密码一项就可以省略了。
2、例2：再将root的密码改为djg345。
mysqladmin -uroot -pab12 password djg345

create database name   建库
use databasename       进库
drop database name     删库
show tables            查表
desc tablename       表的详细描述
flush privileges     刷新数据库

select中加上distinct去除重复字段
mysqladmin drop database name 删除数据库前，有提示

select version(),current_date显示当前版本和当前日期

修改mysql中root的密码
shell>mysql -u root -p
mysql>update user set password=password("lzk123") where user="root";


alter table position add(test char(10))       表position增加字段列test

insert into department(name,description) values（'测试部'，'财务部')插入表department

insert into staffer(name,department_id,position_id) values（'小明',4,1)插入表department

select count(*) from staffer where department_id=4;

delete from departmenet where name="测试部"    # 删除数据记录


drop table(database) 表名称





 













